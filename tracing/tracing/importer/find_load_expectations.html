<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/model/user_model/load_expectation.html">
<link rel="import" href="/tracing/base/math/range.html">

<script>
'use strict';

tr.exportTo('tr.importer', function() {
  const LONG_TASK_THRESHOLD_MS = 50;

  const IGNORE_URLS = [
    // Blank URLs correspond to initial empty loads and we want to ignore
    // them.
    '',
    'about:blank',
  ];

  const simple = value => ({value, diagnostics: {}});

  const closeTo = (a, b, epsilon) => (Math.abs(a-b) < epsilon);

  const assert = (assertion, text) => {
    if (!assertion) {
      console.assert(false, text);
      debugger;
      throw Error(text);
    }
  }

  // Params: (ranges: Range[], clipWindow: Range)
  // @returns Range[]
  // Drops 0 duration ranges, so don't pass instant events into this.
  function clipRanges(ranges, clipWindow) {
    return ranges.map(r => r.findIntersection(clipWindow))
      .filter(r => r.duration > 0);
  }

  // function getJankZoneFromTasks(tasks) {

  // }

  // Params: mainThreadTasks: {start, end}[], clipWindow: Range, jankZonePower: number
  // @returns number
  function computeJankZoneSum(mainThreadTasks, clipWindow, jankZonePower) {
    const jankZones = [];
    for (const task of mainThreadTasks) {
      if (task.duration < 50) continue;
      jankZones.push(tr.b.math.Range.fromExplicitRange(task.start, task.end - 50));
    }
    const clippedJankZones = clipRanges(jankZones, clipWindow);

    let sum = 0;
    for (const range of clippedJankZones) {
      sum += Math.pow(range.duration, jankZonePower);
    }

    return sum;
  }

  /**
   * @param  {!tr.model.Process} process
   * @param  {!tr.b.math.Range} range
   * @return {Array.<tr.model.Event>} An array of network events of a process
   * and that are intersecting a range.
   */
  function getNetworkEventsInRange(process, range) {
    const networkEvents = [];
    for (const thread of Object.values(process.threads)) {
      const threadHelper = new tr.model.helpers.ChromeThreadHelper(thread);
      const events = threadHelper.getNetworkEvents();
      for (const event of events) {
        if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
          networkEvents.push(event);
        }
      }
    }
    return networkEvents;
  }

  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    const objects = rendererHelper.process.objects;
    const frameLoaderInstances = objects.instancesByTypeName_.FrameLoader;
    if (frameLoaderInstances === undefined) return undefined;

    let snapshot;
    for (const instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      const maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args.frame.id_ref) continue;
      snapshot = maybeSnapshot;
    }

    return snapshot;
  }

  function findFirstMeaningfulPaintCandidates(rendererHelper) {
    const candidatesForFrameId = {};
    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!tr.e.chrome.EventFinderUtils.hasCategoryAndName(
          ev, 'loading', 'firstMeaningfulPaintCandidate')) {
        continue;
      }
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      const frameIdRef = ev.args.frame;
      if (frameIdRef === undefined) continue;
      let list = candidatesForFrameId[frameIdRef];
      if (list === undefined) {
        candidatesForFrameId[frameIdRef] = list = [];
      }
      list.push(ev);
    }
    return candidatesForFrameId;
  }

  /**
   * Returns Time to Interactive and First CPU Idle for the
   * given parameters. See the time_to_interactive.html module for detailed
   * description and implementation of these metrics. The two metrics are
   * computed together in the same function because almost all the computed
   * parameters, for example list of relevant long tasks, are same for these two
   * metrics, and this helps avoid duplicate computation.
   *
   * @param {tr.model.helpers.ChromeRendererHelper} rendererHelper - Renderer
   *     helper for the renderer of interest.
   * @param {tr.model.ThreadSlice} navigationStart - The navigation start
   *     event for which loading metrics is being computed.
   * @param {tr.model.ThreadSlice} fmpEvent - The first meaningful paint
   *     event for which loading metrics is being computed.
   * @param {tr.model.ThreadSlice} domContentLoadedEndEvent - Event
   *     corresponding to finish  of dom content loading
   * @param {number} searchWindowEnd - Time till when to search for a TTI. This
   *   value is either the start of next navigation or the end of the trace.
   * @returns {interactiveSample: {number}|undefined,
   *           firstCpuIdleTime: {number}|undefined}
   */
  function computeInteractivityMetricSample_(rendererHelper, navigationStart,
      fmpEvent, domContentLoadedEndEvent, searchWindowEnd, fcpEvent) {
    const xpMetrics = new Map();
    let reachedTTI = false;
    const addMetric = (name, sample) => {
      assert(!xpMetrics.has(name));
      xpMetrics.set(name, sample);
    };
    const getMetricSample = name => {
      const sample = xpMetrics.get(name);
      assert(sample !== undefined, `Metric ${name} was never added`);
      return sample;
    };
    const getMetricValue = name => {
      return getMetricSample(name).value;
    };

    const navigationStartTime = navigationStart.start;
    const resourceLoadEvents =
          tr.e.chrome.EventFinderUtils.getNetworkEventsInRange(
            rendererHelper.process,
            tr.b.math.Range.fromExplicitRange(navigationStart.start,
                                              searchWindowEnd));
    // Cannot determine TTI if DomContentLoadedEnd was never reached or if
    // there is no corresponding fmp/fcpEvent, or if there are no network events
    // in the trace.
    if (domContentLoadedEndEvent === undefined || fmpEvent === undefined
        || fcpEvent === undefined
        || resourceLoadEvents.length === 0) {
      return {
        interactiveTime: undefined,
        firstCpuIdleTime: undefined,
        xpData: {reachedTTI, xpMetrics},
      };
    }
    const firstContentfulPaintTime = fcpEvent.start;
    const firstMeaningfulPaintTime = fmpEvent.start;
    const mainThreadTasks =
        tr.e.chrome.EventFinderUtils.findToplevelSchedulerTasks(
            rendererHelper.mainThread);

    const longTasks = mainThreadTasks.filter(
        task => task.duration >= LONG_TASK_THRESHOLD_MS);
    const longTasksInWindow = longTasks.filter(
        task => task.range.intersectsExplicitRangeInclusive(
            firstMeaningfulPaintTime, searchWindowEnd));


    const firstCpuIdleTime =
        tr.e.chrome.findFirstCpuIdleTime(
            firstMeaningfulPaintTime, searchWindowEnd,
            domContentLoadedEndEvent.start, longTasksInWindow);

    // If we did not find any resource load events, interactiveTime should not
    // be computed to avoid reporting misleading values.
    const interactiveTime = resourceLoadEvents.length > 0 ?
      tr.e.chrome.findInteractiveTime(
          firstMeaningfulPaintTime, searchWindowEnd,
          domContentLoadedEndEvent.start, longTasksInWindow,
          resourceLoadEvents) : undefined;

    // Experimental
    try {
      // Only keeps events that intersect with the [start, end] window.
      const filterToWindow = (tasks, [start, end]) => tasks.filter(
        task => tr.b.math.Range.fromExplicitRange(task.start, task.start + task.duration)
          .intersectsExplicitRangeInclusive(start, end));

      const filterToSearchWindow = longTasks =>
            filterToWindow(longTasks, [firstMeaningfulPaintTime, searchWindowEnd]);

      const tasksLongerThan = threshold =>
            mainThreadTasks.filter(task => task.duration >= threshold);
      const pickLongestTask = tasks => {
        let longest = null;
        let maxDur = 0;
        for (const task of tasks) {
          if (task.duration > maxDur) {
            maxDur = task.duration;
            longest = task;
          }
        }
        return longest;
      }

      const navLongTasks = filterToWindow(tasksLongerThan(LONG_TASK_THRESHOLD_MS),
                                          [navigationStartTime, searchWindowEnd]);

      const long_task_thresholds = [50, 100, 200];
      for (const threshold of long_task_thresholds) {
        const tasksConsidered = filterToSearchWindow(tasksLongerThan(threshold));
        const intTime = tr.e.chrome.findInteractiveTime(
          firstContentfulPaintTime, searchWindowEnd,
          domContentLoadedEndEvent.start,
          tasksConsidered,
          resourceLoadEvents) || 0;

        // Mark TTI reached.
        if (intTime !== 0 && threshold === 50) {
          reachedTTI = true;
        }

        const tti = (intTime !== 0) ? intTime - navigationStart.start : null;
        const fixOrigin = t => t - navigationStartTime;
        addMetric(
          `TTI-${threshold}`, {
            value: (intTime !== 0) ? intTime - navigationStart.start : null,
            diagnostics: {
              navigationStart: navigationStartTime,
              interactiveTime: intTime,
              pid: rendererHelper.process.pid,
              longTasks: navLongTasks.map(t => ({
                start: fixOrigin(t.start),
                end: fixOrigin(t.end),
                dur: t.duration})),
            }
          });

        const fcpToTtiRange = [firstContentfulPaintTime,
                               intTime !== 0 ? intTime : searchWindowEnd];

        const longestTask = pickLongestTask(filterToWindow(
          mainThreadTasks, fcpToTtiRange));
        const longestTaskTs = longestTask ?
              longestTask.start - navigationStart.start: null;
        addMetric(`TTI-${threshold}-LongestTaskDuration`,
                  simple(longestTask ? longestTask.duration : null));
        addMetric(`TTI-${threshold}-LongestTaskTs`,
                 simple(longestTaskTs))

        const longTasksInFcpToTti =
              filterToWindow(tasksConsidered, fcpToTtiRange)
        const lastLongTask =
              longTasksInFcpToTti[longTasksInFcpToTti.length - 1];
        const lastLongTaskDuration = lastLongTask ?
              lastLongTask.duration : null;
        const lastLongTaskTs = lastLongTask ?
              lastLongTask.start - navigationStart.start : null;
        addMetric(`TTI-${threshold}-LastLongTaskDuration`,
                  simple(lastLongTaskDuration));
        addMetric(`TTI-${threshold}-LastLongTaskTs`,
                  simple(lastLongTaskTs));
      };

      if (!reachedTTI) {
        // No point continuing.
        return {interactiveTime, firstCpuIdleTime,
                xpData: {reachedTTI, xpMetrics}};
      }

      addMetric("DCL",
        simple(domContentLoadedEndEvent.start - navigationStart.start));

      const longestTaskInTrace = pickLongestTask(
        filterToWindow(mainThreadTasks,
                       [firstContentfulPaintTime, searchWindowEnd]));
      const longestTaskInTraceDuration = longestTaskInTrace ?
        longestTaskInTrace.duration : null;
      const longestTaskInTraceTs = longestTaskInTrace ?
            longestTaskInTrace.start - navigationStart.start : null;

      addMetric('LongestTaskInTraceDuration',
                    simple(longestTaskInTraceDuration));
      addMetric('LongestTaskInTraceTs',
                simple(longestTaskInTraceTs));


      // TTI with FCP as lower bound. This is the definition used in lighthouse.
      const lighthouseIntTime = getMetricSample('TTI-50').diagnostics.interactiveTime;

      // Do not use hyphens in endpoint name.
      // endpoints must be in order of events so we can have some easy
      // correctness checks.
      const endpoints = [
        { name: 'navStart', time: navigationStartTime },
        { name: 'FCP', time: firstContentfulPaintTime },
        { name: 'Interactive', time: lighthouseIntTime },
        // Technically this could also be navigation end, but we ensure only one navigation.
        { name: 'TtiPlus10s', time: lighthouseIntTime + 10e3},
      ];


      // All tasks in this navigation.
      const tasksInCurrentNavigation = filterToWindow(mainThreadTasks, [navigationStartTime, searchWindowEnd]);
      // All long tasks in this navigation.
      // TODO: Why does tasksLongerThan not take tasks as an argument?

      // Reducer.
      const sumLongTasksFn = clipWindow => (sum, task) => task.duration > 50 ?
            sum + task.range.findExplicitIntersectionDuration(clipWindow[0], clipWindow[1])
            : sum;


      // Reducer
      const sumArray = arr => arr.reduce((acc, x) => acc + x, 0);

      const genMetricName = (endpoints, prefix, i, j) => `${prefix}-${endpoints[i].name}-${endpoints[j].name}`;

      for (let i = 0; i < endpoints.length; i++) {
        for (let j = i + 1; j < endpoints.length; j++) {
          const clipWindow = [endpoints[i].time, endpoints[j].time];

          // Get tasks intersecting with clipWindow. Does not clip tasks.
          const tasksInWindow = filterToWindow(navLongTasks, clipWindow);

          const longTasksSum = tasksInWindow.reduce(sumLongTasksFn(clipWindow), 0);
          addMetric(
            genMetricName(endpoints, 'SumOfLongTasks', i, j),
            simple(longTasksSum));

          const clipWindowRange =
                tr.b.math.Range.fromExplicitRange(clipWindow[0], clipWindow[1]);

          const jankZoneSumP1 = computeJankZoneSum(navLongTasks, clipWindowRange, 1);
          addMetric(genMetricName(endpoints, 'SumOfQueuingTimeGT50_p1.0', i, j),
                    simple(jankZoneSumP1));
          const jankZoneSumP1p5 = computeJankZoneSum(navLongTasks, clipWindowRange, 1.5);
          addMetric(genMetricName(endpoints, 'SumOfQueuingTimeGT50_p1.5', i, j),
                    simple(jankZoneSumP1p5));
          const jankZoneSumP2 = computeJankZoneSum(navLongTasks, clipWindowRange, 2.0);
          addMetric(genMetricName(endpoints, 'SumOfQueuingTimeGT50_p2.0', i, j),
                    simple(jankZoneSumP2));
        }
      }

      const fid_thresholds_ms = [50, 100, 150, 200, 250, 300, 350, 400, 450, 500];
      for (const threshold_ms of fid_thresholds_ms) {
        addMetric(
          `ProbFidMoreThan-${threshold_ms}`,
          simple(tr.e.chrome.computeProbabilityOfHighFidFromTasks(
            tasksInCurrentNavigation, firstContentfulPaintTime, threshold_ms)),
        );
      }

      /*************************************************
       * Sanity checks.
       *************************************************/

      // Assert every interval adds up.
      for (let i = 0; i < endpoints.length; i++) {
        for (let j = i + 1; j < endpoints.length; j++) {
          for (let k = i + 1; k < j - 1; k++) {
            const metric = 'SumOfLongTasks';
            const getName = (name, i, j) => genMetricName(endpoints, name, i, j);
            assert(closeTo(
              getMetricValue(getName(metric, i, j)),
              getMetricValue(getName(metric, i, k)) +
                getMetricValue(getName(metric, k, j)),
              0.001
            ));
          }
        }
      }

      {
        // Assert that as the thresholds increase, the probability for high input
        // decreases.
        const sorted_fid_thresholds_ms = fid_thresholds_ms.sort((a, b) => a - b);
        let curr = Infinity;
        for (const t of sorted_fid_thresholds_ms) {
          const next = getMetricValue(`ProbFidMoreThan-${t}`);
          assert(next <= curr,
                         "Probability of high FID should decrease as threshold increases.");
          curr = next;
        }
      }

      return {interactiveTime, firstCpuIdleTime,
              xpData: {reachedTTI, xpMetrics}};
    } catch (e) {
      console.error(e);
      debugger;
    }
  }

  /* Constructs a loading metrics for the specified navigation start event and
   * the corresponding fmpEvent and returns a sample including the metrics and
   * navigationStartEvent, fmpEvent, url and the frameId.
   *
   * @param {tr.model.helpers.ChromeRendererHelper} rendererHelper - Renderer
   *     helper for the renderer of interest.
   * @param {Map.<string, Array<!tr.model.ThreadSlice>>} frameToNavStartEvents -
   *     Map from frame ids to sorted array of navigation start events.
   * @param {Map.<string, Array<!tr.model.ThreadSlice>>}
   *     frameToDomContentLoadedEndEvents - Map from frame ids to sorted array
   *     of DOMContentLoadedEnd events.
   * @param {tr.model.ThreadSlice} navigationStart - The navigation start
   *     event for which loading metrics is being computed.
   * @param {tr.model.ThreadSlice} fmpEvent - The first meaningful paint
   *     event for which loading metrics is being computed.
   * @param {number} searchWindowEnd - The end of the current navigation either
   *     because new navigation has started or the trace has ended.
   * @param {string} url - URL of the current main frame document.
   * @param {number} frameId - fameId.
   * @retcollectMetricsFromLoadExpectationsurner}, duration: {number},
   *  fmpEvent: {tr.model.ThreadSlice}, navStart: {tr.model.ThreadSlice},
   *  dclEndTime: {tr.model.ThreadSlice}, firstCpuIdleTime: {number}|undefined,
   *  interactiveSample: {number}|undefined, url: {string}, frameId: {number}}}
   */
  function constructLoadingExpectation_(rendererHelper,
      frameToDomContentLoadedEndEvents, navigationStart, fmpEvent,
      searchWindowEnd, url, frameId) {
    // Find when dom content has loaded.
    const dclTimesForFrame =
        frameToDomContentLoadedEndEvents.get(frameId) || [];
    const dclSearchRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, searchWindowEnd);
    const dclTimesInWindow =
        dclSearchRange.filterArray(dclTimesForFrame, event => event.start);
    let domContentLoadedEndEvent = undefined;
    if (dclTimesInWindow.length !== 0) {
      // TODO(catapult:#3796): Ideally a frame should reach DomContentLoadedEnd
      // at most once within two navigationStarts, but sometimes there is a
      // strange DclEnd event immediately following the navigationStart, and
      // then the 'real' dclEnd happens later. It is not clear how to best
      // determine the correct dclEnd value. For now, if there are multiple
      // DclEnd events in the search window, we just pick the last one.
      domContentLoadedEndEvent =
        dclTimesInWindow[dclTimesInWindow.length - 1];
    }

    // EFID code.
    // FROM https://chromium-review.googlesource.com/c/catapult/+/921483/3/tracing/tracing/importer/find_load_expectations.html#203
    const frameToFCPEvents =
          tr.e.chrome.EventFinderUtils.getSortedMainThreadEventsByFrame(
            rendererHelper, 'firstContentfulPaint', 'loading');
    const fcpEventsForFrame = frameToFCPEvents.get(frameId) || [];
    // Reuse the dclSearchRange.
    const fcpEventsInWindow =
          dclSearchRange.filterArray(fcpEventsForFrame, event => event.start);
    let fcpEvent = undefined;
    if (fcpEventsInWindow.length !== 0) {
      // There really shouldn't be more than one FCP event, but if there is,
      // pick the last one.
      fcpEvent = fcpEventsInWindow[fcpEventsInWindow.length - 1];
    }

    // Experimental
    try {

      const expectedFIDData = tr.e.chrome.computeExpectedFID(
        rendererHelper, fcpEvent);

      const {interactiveTime, firstCpuIdleTime,
             xpData} =
            computeInteractivityMetricSample_(
              rendererHelper, navigationStart, fmpEvent,
              domContentLoadedEndEvent, searchWindowEnd, fcpEvent);

      const duration = (interactiveTime === undefined) ?
            searchWindowEnd - navigationStart.start :
            interactiveTime - navigationStart.start;


      return new tr.model.um.LoadExpectation(
        rendererHelper.modelHelper.model,
        tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL, navigationStart.start,
        duration, rendererHelper.process, navigationStart, fmpEvent,
        domContentLoadedEndEvent, firstCpuIdleTime, interactiveTime, url,
        frameId, fcpEvent, expectedFIDData, xpData);
    } catch (e) {
      console.error(e);
      debugger;
    }

  }

  /**
   * Computes the loading expectations for a renderer represented by
   * |rendererHelper| and returns a list of samples. The loading
   * expectation is the time between navigation start and the time to
   * be interactive. There will be one load expectation corresponding
   * to each navigation start for loading main frames.
   *
   * Also, computes Time to First Meaningful Paint (TTFMP), and
   * Time to First CPU Idle (TTFCI) along with time to interactive (TTI)
   * and returns them along with the load expectation.
   *
   * First meaningful paint is the paint following the layout with the highest
   * "Layout Significance". The Layout Significance is computed inside Blink,
   * by FirstMeaningfulPaintDetector class. It logs
   * "firstMeaningfulPaintCandidate" event every time the Layout Significance
   * marks a record. TTFMP is the time between NavigationStart and the last
   * firstMeaningfulPaintCandidate event.
   *
   * Design doc: https://goo.gl/vpaxv6
   *
   * Time to Interactive and Time to First CPU Idle is based on heuristics
   * involving main thread and network activity, as well as First Meaningful
   * Paint and DOMContentLoadedEnd event. See time_to_interactive.html module
   * for detailed description and implementation of these two metrics.
   */
  function collectLoadExpectationsForRenderer(
      rendererHelper) {
    const samples = [];
    const frameToNavStartEvents =
        tr.e.chrome.EventFinderUtils.getSortedMainThreadEventsByFrame(
            rendererHelper, 'navigationStart', 'blink.user_timing');
    const frameToDomContentLoadedEndEvents =
          tr.e.chrome.EventFinderUtils.getSortedMainThreadEventsByFrame(
              rendererHelper, 'domContentLoadedEventEnd', 'blink.user_timing');

    function addSamples(frameIdRef, navigationStart, fmpCandidateEvents,
        searchWindowEnd, url) {
      let fmpMarkerEvent =
            tr.e.chrome.EventFinderUtils.
                findLastEventStartingOnOrBeforeTimestamp(fmpCandidateEvents,
                    searchWindowEnd);
      if (fmpMarkerEvent !== undefined &&
        navigationStart.start > fmpMarkerEvent.start) {
        // Don't use fmpCandidate if it is not corresponding this navigation.
        fmpMarkerEvent = undefined;
      }
      samples.push(constructLoadingExpectation_(
          rendererHelper, frameToDomContentLoadedEndEvents, navigationStart,
          fmpMarkerEvent, searchWindowEnd, url, frameIdRef));
    }

    const candidatesForFrameId =
        findFirstMeaningfulPaintCandidates(rendererHelper);

    for (const [frameIdRef, navStartEvents] of frameToNavStartEvents) {
      const fmpCandidateEvents = candidatesForFrameId[frameIdRef] || [];
      let prevNavigation = {navigationEvent: undefined, url: undefined};

      for (let index = 0; index < navStartEvents.length; index++) {
        const currNavigation = navStartEvents[index];
        let url;
        let isLoadingMainFrame = false;

        if (currNavigation.args.data) {
          url = currNavigation.args.data.documentLoaderURL;
          isLoadingMainFrame = currNavigation.args.data.isLoadingMainFrame;
        } else {
          // TODO(#4358): Delete old path of obtaining URL.
          const snapshot = findFrameLoaderSnapshotAt(
              rendererHelper, frameIdRef, currNavigation.start);
          if (snapshot) {
            url = snapshot.args.documentLoaderURL;
            isLoadingMainFrame = snapshot.args.isLoadingMainFrame;
          }
        }

        // Filter navigationStartEvents that do not correspond to a loading main
        // frame, or has a URL that we do not care about.
        if (!isLoadingMainFrame) continue;
        if (url === undefined || IGNORE_URLS.includes(url)) continue;

        if (prevNavigation.navigationEvent !== undefined) {
          // Add a LoadExpectation for the previous navigation ending on or
          // before current navigation.
          addSamples(frameIdRef, prevNavigation.navigationEvent,
              fmpCandidateEvents, currNavigation.start, prevNavigation.url);
        }

        prevNavigation = {navigationEvent: currNavigation, url};
      }

      // Handle the last navigation here.
      if (prevNavigation.navigationEvent !== undefined) {
        addSamples(frameIdRef, prevNavigation.navigationEvent,
            fmpCandidateEvents, rendererHelper.modelHelper.chromeBounds.max,
            prevNavigation.url);
      }
    }
    return samples;
  }


  function findLoadExpectations(modelHelper) {
    const loads = [];

    const chromeHelper = modelHelper.model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      loads.push.apply(loads,
          collectLoadExpectationsForRenderer(rendererHelper));
    }
    return loads;
  }

  return {
    findLoadExpectations,
    clipRanges,
    computeJankZoneSum,
  };
});
</script>
