<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/helpers/chrome_thread_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const EventFinderUtils = tr.e.chrome.EventFinderUtils;

  /**
   * @param  {!tr.model.Process} process
   * @param  {!tr.b.math.Range} range
   * @return {Array.<tr.model.Event>} An array of network events of a process
   * and that are intersecting a range.
   */
  function getNetworkEventsInRange(process, range) {
    const networkEvents = [];
    for (const thread of Object.values(process.threads)) {
      const threadHelper = new tr.model.helpers.ChromeThreadHelper(thread);
      const events = threadHelper.getNetworkEvents();
      for (const event of events) {
        if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
          networkEvents.push(event);
        }
      }
    }
    return networkEvents;
  }

  const LOADING_METRIC_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createLinear(0, 1e3, 20)  // 50ms step to 1s
      .addLinearBins(3e3, 20) // 100ms step to 3s
      .addExponentialBins(20e3, 20);

  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: false,
    min: false,
    std: false,
    sum: false,
  };

  function addSamplesToHistogram(pairInfo, breakdown, histogram, histograms) {
    histogram.addSample(pairInfo.to - pairInfo.from, {});
    if (!breakdown) {
      return;
    }
    for (const [category, value] of Object.entries(breakdown)) {
      const relatedName = `${histogram.name}:${category}`;
      const relatedHist = histograms.createHistogram(
          relatedName, histogram.unit, [], {
            binBoundaries: LOADING_METRIC_BOUNDARIES,
            summaryOptions: {
              count: false,
              max: false,
              min: false,
              sum: false,
            },
          });
      // Value can be further broken down to events.
      relatedHist.addSample(value.total, {});
    }
  }

  function getEndTime(model) {
    return model.bounds.max;
  }

  function getPerSecondFromToPairs(navigationStart, endTime) {
    const pushToResults = (results, from, navigationStart) => {
      const to = from + 1000;
      const realFrom = navigationStart + from;
      const realTo = navigationStart + to;
      results.push({from, to, realFrom, realTo});
    };
    const results = [];
    let from = 0;
    while (navigationStart + from + 1000 < endTime) {
      pushToResults(results, from, navigationStart);
      from += 1000;
    }
    pushToResults(results, from, navigationStart);
    return results;
  }

  function getNavigationStartInfos(model) {
    const navigationStartInfos = [];
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    for (const expectation of model.userModel.expectations) {
      if (!(expectation instanceof tr.model.um.LoadExpectation)) continue;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(expectation.url)) {
        continue;
      }
      const rendererHelper = chromeHelper.rendererHelpers[
          expectation.renderProcess.pid];
      navigationStartInfos.push({
        navigationStart: expectation.navigationStart,
        rendererHelper,
      });
    }
    return navigationStartInfos;
  }

  function getRendererHelpers(model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const rendererHelpers = [];
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;
      rendererHelpers.push(rendererHelper);
    }
    return rendererHelpers;
  }

  function getWallTimeBreakdown(rendererHelper, from, to) {
    const fromToRange = tr.b.math.Range.fromExplicitRange(from, to);
    const networkEvents = getNetworkEventsInRange(
        rendererHelper.process, fromToRange);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, fromToRange);
    return breakdownTree;
  }

  function getCpuTimeBreakdown(rendererHelper, from, to) {
    const fromToRange = tr.b.math.Range.fromExplicitRange(from, to);
    const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
        rendererHelper.mainThread, fromToRange);
    return breakdownTree;
  }

  function persecondMetric(histograms, model) {
    const endTime = getEndTime(model); // end of trace
    const rendererHelpers = getRendererHelpers(model);
    const navigationStartInfos = getNavigationStartInfos(model);
    if (navigationStartInfos.length === 0) {
      return;
    }
    const lastNavigationStart =
        navigationStartInfos[navigationStartInfos.length - 1];
    // [{from:0, to:1}, {from:1, to:2}, ...]
    const fromToPairs = getPerSecondFromToPairs(
        lastNavigationStart.navigationStart.start, endTime);

    // Drop the last incomplete second.
    fromToPairs.pop();

    // [{from:0, to:1, realFrom, realTo},
    //  {from:1, to:2, realFrom, realTo}, ...]
    const breakdownList = fromToPairs.map(p => {
      const wallHistogramName = `wall_${p.from}_to_${p.to}`;
      const cpuHistogramName = `cpu_${p.from}_to_${p.to}`;
      return Object.assign(p,
          {
            breakdown: getWallTimeBreakdown(
                lastNavigationStart.rendererHelper, p.realFrom, p.realTo),
            cpuBreakdown: getCpuTimeBreakdown(
                lastNavigationStart.rendererHelper, p.realFrom, p.realTo),
            wallHistogramName,
            cpuHistogramName,
          });
    });
    breakdownList.forEach(p => {
      // entry === {from:0, to:1, realFrom, realTo, breakdown, cpuBreakdown}
      const wallHistogram = histograms.createHistogram(
          `wall_${p.from}_to_${p.to}`, timeDurationInMs_smallerIsBetter, [], {
            binBoundaries: LOADING_METRIC_BOUNDARIES,
            description: `Wall-clock time ${p.from} to ${p.to} breakdown`,
            summaryOptions: SUMMARY_OPTIONS,
          });
      addSamplesToHistogram(p, p.breakdown, wallHistogram, histograms);

      const cpuHistogram = histograms.createHistogram(
          `cpu_${p.from}_to_${p.to}`, timeDurationInMs_smallerIsBetter, [], {
            binBoundaries: LOADING_METRIC_BOUNDARIES,
            description: `CPU time ${p.from} to ${p.to} breakdown`,
            summaryOptions: SUMMARY_OPTIONS,
          });
      addSamplesToHistogram(p, p.cpuBreakdown, cpuHistogram, histograms);
    });
  }

  tr.metrics.MetricRegistry.register(persecondMetric);

  return {
    persecondMetric,
    getPerSecondFromToPairs
  };
});
</script>
