{
  "comments": [
    {
      "key": {
        "uuid": "df359f62_93858905",
        "filename": "dashboard/dashboard/pinpoint/models/evaluators/__init__.py",
        "patchSetId": 6
      },
      "lineNbr": 166,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "This param name looks like it\u0027s a fixed value, but it\u0027s actually a callable, so `key_func` or `key_callable` would be a clearer name.\n\nBut also, see next comment.",
      "range": {
        "startLine": 166,
        "startChar": 60,
        "endLine": 166,
        "endChar": 63
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a7cf77f_ebf7c88b",
        "filename": "dashboard/dashboard/pinpoint/models/evaluators/__init__.py",
        "patchSetId": 6
      },
      "lineNbr": 190,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "Given that only subclasses are setting this parameter it seems like a more natural contract for subclassing would be to have a method to override?\n\nOverriding a method would also have the benefit of making the type of `key` self-documenting.  E.g.:\n\nclass DispatchEvaluatorBase(object):\n  …\n  def _key(self, task, event):\n    \"\"\"Extract the key for a given task \u0026 event.\"\"\"\n    raise NotImplementedError(\"Must be overridden by subclasses\")\n\nclass DispatchByTaskStatus(DispatchEvaluatorBase):\n  \n  def _key(self, task, event):\n    return task.status\n\n# etc.\n\n(Perhaps decorated with @classmethod or @staticmethod if that seems clearer?)",
      "range": {
        "startLine": 190,
        "startChar": 59,
        "endLine": 190,
        "endChar": 78
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "810e413f_f8d8e0f1",
        "filename": "dashboard/dashboard/pinpoint/models/evaluators/job_serializer.py",
        "patchSetId": 6
      },
      "lineNbr": 146,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "Nit: The previous line already verified this key exists, so just use []:\n\n  modification \u003d local_accumulator[\u0027state\u0027]",
      "range": {
        "startLine": 146,
        "startChar": 21,
        "endLine": 146,
        "endChar": 51
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ad11f00_e774b619",
        "filename": "dashboard/dashboard/pinpoint/models/evaluators/job_serializer.py",
        "patchSetId": 6
      },
      "lineNbr": 180,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "This is buggy.  [x].__mul__(n) doesn\u0027t give you a list with n copies of x.  It gives you a list with the same instance of x, n times.  So [{}] * 5 is like:\n\n  \u003e\u003e\u003e x \u003d {}; n \u003d 5; l \u003d []\n  \u003e\u003e\u003e for _ in range(n): l.append(x)\n  ...\n\nMutating any element of that list will mutate all of them, because they\u0027re all the same object.\n\nE.g.:\n\n  \u003e\u003e\u003e l \u003d []\n  \u003e\u003e\u003e l.extend([{\u0027x\u0027: []}] * 3)\n  \u003e\u003e\u003e l[0][\u0027x\u0027]\n  []\n  \u003e\u003e\u003e l[0][\u0027x\u0027].append(\u0027foo\u0027)\n  \u003e\u003e\u003e l\n  [{\u0027x\u0027: [\u0027foo\u0027]}, {\u0027x\u0027: [\u0027foo\u0027]}, {\u0027x\u0027: [\u0027foo\u0027]}]\n\n\nSo you\u0027re going to need a loop here (or a list comprehension, which is just more error-prone syntax for this sort of loop, so probably a loop is best.…).\n\n  while len(attempts) \u003c attempt_index:\n    attempts.append({\u0027executions\u0027: []})\n\nFortunately, this is actually more concise and easier to read, and in practice is probably basically as fast (modulo the extra allocations needed for the distinct dicts and lists for each element, but we want those).\n\nAlso: why didn\u0027t the tests catch this?  I assume you\u0027re missing some coverage.",
      "range": {
        "startLine": 178,
        "startChar": 26,
        "endLine": 180,
        "endChar": 14
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f634a03d_88c51590",
        "filename": "dashboard/dashboard/pinpoint/models/evaluators/job_serializer.py",
        "patchSetId": 6
      },
      "lineNbr": 183,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "In contrast this is fine, because None is immutable, so it doesn\u0027t matter that all the elements point to the same None object.  (Also None is a singleton object anyway, but it\u0027s the immutability that matters for this.)\n\nAlthough it does still have the awkward index arithmetic that is prone to off-by-one errors, so not clearly better than a loop.",
      "range": {
        "startLine": 183,
        "startChar": 28,
        "endLine": 183,
        "endChar": 38
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "60fc9e28_d1ad943c",
        "filename": "dashboard/dashboard/pinpoint/models/evaluators/job_serializer.py",
        "patchSetId": 6
      },
      "lineNbr": 201,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "This is a relatively expensive operation.  Unfortunately python\u0027s logging package doesn\u0027t provide a convenient way to defer evaluation of expensive expressions until it is sure it will actually log them (at least that I know of, although I can imagine nasty hacks…).  So I guess leave this as is for now, but keep in mind that this might turn out to be a hotspot later.",
      "range": {
        "startLine": 201,
        "startChar": 41,
        "endLine": 201,
        "endChar": 69
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b510bb68_3a23c82a",
        "filename": "dashboard/dashboard/pinpoint/models/evaluators/job_serializer.py",
        "patchSetId": 6
      },
      "lineNbr": 258,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "This usage isn\u0027t exactly an accumulation.  ;)\n\nI\u0027m starting to think the “accumulator” concept may be misnamed.",
      "range": {
        "startLine": 257,
        "startChar": 0,
        "endLine": 258,
        "endChar": 28
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "92ef6368_c3215c3f",
        "filename": "dashboard/dashboard/pinpoint/models/tasks/performance_bisection.py",
        "patchSetId": 6
      },
      "lineNbr": 520,
      "author": {
        "id": 1284623
      },
      "writtenOn": "2019-11-19T05:40:20Z",
      "side": 1,
      "message": "As this class has no state perhaps this should just be a function?\n\n(Same question applies to some of the other serializers too.)",
      "range": {
        "startLine": 518,
        "startChar": 0,
        "endLine": 520,
        "endChar": 43
      },
      "revId": "be44f172164b8f59c528b2655410e7ad1fcf3729",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}